import com.atlassian.jira.component.ComponentAccessor
import com.atlassian.jira.bc.issue.search.SearchService
import com.atlassian.jira.jql.parser.JqlQueryParser
import com.atlassian.jira.web.bean.PagerFilter
import com.atlassian.jira.issue.link.IssueLinkTypeManager
import com.atlassian.jira.security.roles.ProjectRoleManager
import java.sql.Timestamp
import com.atlassian.jira.issue.Issue
import com.atlassian.jira.issue.context.IssueContext
import com.atlassian.jira.issue.context.IssueContextImpl
import com.atlassian.jira.issue.fields.config.manager.PrioritySchemeManager

def jqlToUrl (String jql) {
	def UrlizedJql = "${com.atlassian.jira.component.ComponentAccessor.getApplicationProperties().getString("jira.baseurl")}/issues/?jql=" + jql.replaceAll(/ /, "%20").replaceAll(/=/, "%3D").replaceAll("\"", "%22").replaceAll(",", "%2C")
	return UrlizedJql
}

/*
currentIssue definition is just type casting for further usage. 
'issue.key' here and 'issue' itself is the context constant passed from rule execution. 
It's handy and can be used anywhere (even inside the methods), but the code becomes not flexible, and can't be easily debugged in console.
*/
def currentIssue = ComponentAccessor.getIssueManager().getIssueObject(issue.key)  // you can replace issue.key with some actual issue key to use the script in console, e.g. <...>.getIssueObject("PRJ-78") 
def issueComponent = currentIssue.getComponents().head().name //getting only first component. BTW, script will fail if components are empty
def jqlQueryParser = ComponentAccessor.getComponent(JqlQueryParser)
def searchService = ComponentAccessor.getComponent(SearchService.class)
def pager = PagerFilter.getUnlimitedFilter()
def user = ComponentAccessor.getJiraAuthenticationContext().getLoggedInUser()
def projectName = "${currentIssue.key}".replaceAll(/-.*/, "")
def Boolean ticketCreatedFlag = false //this one is to avoid creating multiple problems by this rule. 
def createdDateValue = new Date()
def visibility = "Staff only" //Name of the visibility group for comment. Default is for Project Roles name. Should be replaced with proper. It may be not useful for someone. You can just comment it out. Also you need to change makeComment function. 
def Integer repeatableCheckGap = 15 // this set time gap in minutes for finding repeatable issues


def makeComment (Issue issueToComment, String commentText, com.atlassian.jira.user.ApplicationUser commentUser, String vis) {  //at this point I'm not sure why do I need this method. Probably only because it looks more humanfriendly in code
	//only one line should be here. Commented lines are replacements in case you need other comment visibility options.
	ComponentAccessor.commentManager.create(issueToComment, commentUser, commentText, null,ComponentAccessor.getComponent(ProjectRoleManager).getProjectRole("${vis}").getId(), true) //comment this line if you don't need visibility functionality.
	//ComponentAccessor.commentManager.create(issueToComment, commentUser, commentText, vis, null, true) //uncomment this line, and 'visibility' variable will set comment visibility for names of global user groups (from User Management tab)
	//ComponentAccessor.commentManager.create(issueToComment, commentUser, commentText, null, null, true) //uncomment this line if you don't need visibility functionality. All comments will have default visibility.
}


/*
Function for linked problem creation
Example: createLinkedProblem(rootIssue, listRepeatableDaily, "Problem", "Test", "Normal", "Найден ежедневно повторяющийся алерт", projectName, user, visibility)
This will create Problem linked to rootIssue with summary Test, priority Normal. Description will be like:

Найден ежедневно повторяющийся алерт.
ISSUEKEY - ISSUESUMMARY Created: 1970-01-01 00:00 Resolved: 1970-01-01 00:05
ISSUEKEY - ISSUESUMMARY Created: 1970-01-01 00:00 Resolved: 1970-01-01 00:05
ISSUEKEY - ISSUESUMMARY Created: 1970-01-01 00:00 Resolved: 1970-01-01 00:05
ISSUEKEY - ISSUESUMMARY Created: 1970-01-01 00:00 Resolved: 1970-01-01 00:05
ISSUEKEY - ISSUESUMMARY Created: 1970-01-01 00:00 Resolved: 1970-01-01 00:05
ISSUEKEY - ISSUESUMMARY Created: 1970-01-01 00:00 Resolved: 1970-01-01 00:05
ISSUEKEY - ISSUESUMMARY Created: 1970-01-01 00:00 Resolved: 1970-01-01 00:05

Issue keys are took from incidentList (the first variable)+the issue which triggered the problem creation.
problemProjectName is for project to create issue in
user is comments' author and issue reporter.
visibility is for comments visibility

After issue creation all issues from incidentList and the issue which triggered the rule will get linked to Problem as 'is caused by' in problem.

You can set created Problem summary based on issue's description like so (just example):

String dailyProblemSummary = "[RPTISSUE] ${listRepeatableDaily.summary.get(0).replaceAll("Zabbix.* - |Prometheus |test|prod|preprod|dev", "")}"

TODO: need to rewrite it, to be able to work when incidentList is null. At this point I don't need it, since It's being triggered only for repeatable incidents of all kinds.
*/

def createLinkedProblem	 (Issue rootIssue, List<Issue> incidentList, String issueTypeName, String problemSummary, String priorityName, String shortDesc, String problemProjectName, com.atlassian.jira.user.ApplicationUser problemAuthor, String commentsVisibility) {
	def issueService = ComponentAccessor.issueService
	def constantsManager = ComponentAccessor.constantsManager
	def prioritySchemeManager = ComponentAccessor.getComponent(PrioritySchemeManager)
	def project = ComponentAccessor.projectManager.getProjectObjByKey(problemProjectName)
	assert project : "Could not find project with key $project"
	def description =shortDesc+""".
	${rootIssue.key} - ${rootIssue.summary} Created: ${rootIssue.created.toString().replaceAll(":.{2}[.].{1,3}", "")} Resolved: ${if (rootIssue.getCustomFieldValue(ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName("Inc Good Time")) == null) {return "Not resolved"} else {rootIssue.getCustomFieldValue(ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName("Inc Good Time")).toString().replaceAll(":.{2}[.].{1,3}", "")}} 
    """
    incidentList.each {result ->; description += """ ${result.key} - ${result.summary} Created: ${result.created.toString().replaceAll(":.{2}[.].{1,3}", "")} Resolved: ${if (result.getCustomFieldValue(ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName("Inc Good Time")) == null) {return "Not resolved"} else {result.getCustomFieldValue(ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName("Inc Good Time")).toString().replaceAll(":.{2}[.].{1,3}", "")}} 
    """}
	description += """ """
	
	def issueType = constantsManager.allIssueTypeObjects.findByName(issueTypeName)
	assert issueType : "Could not find issue type with name $issueTypeName"

	
	//next is some jira magic for preparing issueNewProblem to be created
	def issueContext = new IssueContextImpl(project, issueType) as IssueContext
	def priorityId = constantsManager.priorities.findByName(priorityName)?.id ?: prioritySchemeManager.getDefaultOption(issueContext)
    def component = rootIssue.getComponents()
	def issueNewProblem = ComponentAccessor.getIssueFactory().getIssue()
	issueNewProblem.setProjectId(project.id)
    issueNewProblem.setComponent(component)
	issueNewProblem.setIssueTypeId(issueType.id)
	issueNewProblem.setReporterId(problemAuthor.name)
    issueNewProblem.setFixVersions(rootIssue.fixVersions)
	issueNewProblem.setSummary(problemSummary)
	issueNewProblem.setPriorityId(priorityId)
	issueNewProblem.setDescription(description)
	def subTask = ComponentAccessor.getIssueManager().createIssueObject(problemAuthor, issueNewProblem) //this one finally creates the issueNewProblem, and after that line we can address it as regular issue
	
    def commentAboutCreatedProblem = shortDesc+". Создан ${issueTypeName} ${issueNewProblem.key}"
    makeComment(rootIssue, commentAboutCreatedProblem, problemAuthor, commentsVisibility)
	
	//linking the 'issue' which triggered the rule
	def linkType = ComponentAccessor.getComponent(IssueLinkTypeManager).issueLinkTypes.findByName("Problem/Incident")
    //def sourceIssue = ComponentAccessor.issueManager.getIssueByCurrentKey("${issue.key}")
    def destinationIssue = ComponentAccessor.issueManager.getIssueByCurrentKey(issueNewProblem.key)
    ComponentAccessor.issueLinkManager.createIssueLink(rootIssue.id, destinationIssue.id, linkType.id, 1L, problemAuthor)
	
	//linking all issues from incidentList
	incidentList.each {result ->;
	def sourceIssue = ComponentAccessor.issueManager.getIssueByCurrentKey(result.key)
	ComponentAccessor.issueLinkManager.createIssueLink(sourceIssue.id, destinationIssue.id, linkType.id, 1L, problemAuthor)
	}
}


//Next part is for simple jql based analyze of issue. Lots of comments and all is based on 'if' conditions. TODO: rewrite it to be a bit more human-friendly

def queryWithoutLinkLast2Days = "type = Incident AND project = ${projectName} AND component = ${issueComponent} AND issueLinkType != causes AND createdDate > -48h AND issuekey != ${currentIssue.key} ORDER BY created DESC"
def queryOpenedProblems = "type != Incident AND project = ${projectName} AND issueFunction in linkedIssuesOf(\"type=Incident AND component = ${issueComponent}\", causes) AND status != Closed ORDER BY created DESC"
def queryRepeatable12h = "type = Incident AND project = ${projectName} AND component = ${issueComponent} AND summary ~ \"${currentIssue.summary}\" AND createdDate > -12h ORDER BY created DESC"
def queryOpenedLinkedHit = "type != Incident AND project = ${projectName} AND issueFunction in linkedIssuesOf(\"type=Incident AND component = ${issueComponent} and summary ~\'${currentIssue.summary}\'\", causes) AND status != Closed ORDER BY created DESC"
def queryOpenIncidents = "type = Incident AND project = ${projectName} AND component = ${issueComponent} AND status != Closed ORDER BY created DESC"

def resultsWithoutLinkLast2Days = searchService.search(user, jqlQueryParser.parseQuery(queryWithoutLinkLast2Days), pager)
def resultsOpenedProblems = searchService.search(user, jqlQueryParser.parseQuery(queryOpenedProblems), pager)
def resultsRepeatable12h = searchService.search(user, jqlQueryParser.parseQuery(queryRepeatable12h), pager)
def resultsOpenedLinkedHit = searchService.search(user, jqlQueryParser.parseQuery(queryOpenedLinkedHit), pager)
def resultsOpenIncidents = searchService.search(user, jqlQueryParser.parseQuery(queryOpenIncidents), pager)

//Next part is related to repeatable issues analyze. 
//TODO: rewrite it into method.

List<Issue> listRepeatableDaily = new ArrayList<Issue>()
for (Integer i = 1; i < 8; i++) {
   /*
   Next two lines are ugly as hell, but it works. Probably did a bad job trying to match all those timestamps/dates and JQL requirements. Will mark it as TODO, this definetely can and must be simplified.
   replaceAll at the end is required since JQL don't want to work when Timestamp has seconds and milliseconds, so this regexp just removes them.
   also defining variables in each iteration feels wrong to me, TODO rewriting that part.
   */
   def dailyCheckFrom = "${(new Date(createdDateValue.getTime()- i*(86400000) - repeatableCheckGap*60*1000)).toTimestamp()}".replaceAll(":.{2}[.].{1,3}", "") //this sets starting time to find repeatable issues. 86400000 is 24hours in milliseconds.
   def dailyCheckTill = "${(new Date(createdDateValue.getTime()- i*(86400000) + repeatableCheckGap*60*1000)).toTimestamp()}".replaceAll(":.{2}[.].{1,3}", "") //this sets ending time to find repeatable issues. 86400000 is 24hours in milliseconds
   def queryRepeatableDaily = "type = Incident AND project = ${projectName} AND component = ${issueComponent} AND summary ~ \"${currentIssue.summary}\" AND createdDate > \"${dailyCheckFrom}\" and createdDate < \"${dailyCheckTill}\" ORDER BY created DESC"
   def resultsRepeatableDaily = searchService.search(user, jqlQueryParser.parseQuery(queryRepeatableDaily), pager)
   if (resultsRepeatableDaily.total == 1) { //maybe should use > 1 instead. In such case, need to change listRepeatableDaily defining to work with all results (not only the first as now). But in current design and workload I need == 1. Can hardly imagine more than 1 incident for Component + Summary created in 30 minutes gap per Project.
       listRepeatableDaily.add(resultsRepeatableDaily.results.get(0))
   }
}


List<Issue> listRepeatableWeekly = new ArrayList<Issue>()

for (Integer i = 1; i < 5; i++) {
   def weeklyCheckFrom = "${(new Date(createdDateValue.getTime()- i*(604800000) - repeatableCheckGap*60*1000)).toTimestamp()}".replaceAll(":.{2}[.].{1,3}", "") //this sets starting time to find repeatable issues. 604800000 is 7days in milliseconds.
   def weeklyCheckTill = "${(new Date(createdDateValue.getTime()- i*(604800000) + repeatableCheckGap*60*1000)).toTimestamp()}".replaceAll(":.{2}[.].{1,3}", "") //this sets ending time to find repeatable issues. 604800000 is 24hours in milliseconds
   def queryRepeatableWeekly = "type = Incident AND project = ${projectName} AND component = ${issueComponent} AND summary ~ \"${currentIssue.summary}\" AND createdDate > \"${weeklyCheckFrom}\" and createdDate < \"${weeklyCheckTill}\" ORDER BY created DESC"
   def resultsRepeatableWeekly = searchService.search(user, jqlQueryParser.parseQuery(queryRepeatableWeekly), pager)
   if (resultsRepeatableWeekly.total == 1) { //maybe should use > 1 instead. In such case, need to change commentRepeatableWeekly defining to work with all results (not only the first as now). But in current design and workload I need == 1. Can hardly imagine more than 1 incident for Component + Summary created in 30 minutes gap per Project.
		listRepeatableWeekly.add(resultsRepeatableWeekly.results.get(0))
   }
}


/* 
The part with comments.
Unfortunately at this point all those if's seem to be required, since I'm not only giving the information, but also making comment decisions based on results combinations. 
And AFAIK there are no conditional Switch/Case in Java
*/

//TODO: Rewrite this whole section. I need only one comment for issue analysis and one for some action done (like problem creation or linking to existing). There are to much excessive comments and makeComment calls. 

if (resultsOpenedProblems.total > 0 && resultsWithoutLinkLast2Days.total == 0 && resultsOpenedLinkedHit.total == 0) {
    final String commentBody = """По компоненту существуют открытые связанные заявки, в которых может производиться исследование проблем: [${resultsOpenedProblems.total}|${jqlToUrl(queryOpenedProblems)}]
	Точного наличия открытого исследования по этому алерту установить не удалось."""
	makeComment(currentIssue, commentBody, user, visibility)
}

if (resultsOpenedProblems.total > 0 && resultsWithoutLinkLast2Days.total == 0 && resultsOpenedLinkedHit.total > 0) {
    final String commentBody = """Найдена открытая заявка(и), в которой производится исследование этого алерта: [${resultsOpenedLinkedHit.total}|${jqlToUrl(queryOpenedLinkedHit)}]
	Также, по компоненту существуют открытые связанные заявки (могут совпадать с вышенайденными): [${resultsOpenedProblems.total}|${jqlToUrl(queryOpenedProblems)}]"""
	makeComment(currentIssue, commentBody, user, visibility)
}

if (resultsOpenedProblems.total > 0 && resultsWithoutLinkLast2Days.total > 0 && resultsOpenedLinkedHit.total == 0) {
    final String commentBody = """По компоненту существуют открытые связанные заявки: [${resultsOpenedProblems.total}|${jqlToUrl(queryOpenedProblems)}]
	За последние двое суток инцидентов по этому компоненту, не связанных с другими заявками: [${resultsWithoutLinkLast2Days.total}|${jqlToUrl(queryWithoutLinkLast2Days)}]
	Точного наличия открытого исследования по этому алерту установить не удалось. Создайте его, если это необходимо"""
	makeComment(currentIssue, commentBody, user, visibility)
}

if (resultsOpenedProblems.total > 0 && resultsWithoutLinkLast2Days.total > 0 && resultsOpenedLinkedHit.total > 0) {
    final String commentBody = """Найдена открытая заявка(и), в которой производится исследование этого алерта: [${resultsOpenedLinkedHit.total}|${jqlToUrl(queryOpenedLinkedHit)}]
	Также, по компоненту существуют открытые связанные заявки (могут совпадать с вышенайденными): [${resultsOpenedProblems.total}|${jqlToUrl(queryOpenedProblems)}]
	За последние двое суток инцидентов по этому компоненту, не связанных с другими заявками: [${resultsWithoutLinkLast2Days.total}|${jqlToUrl(queryWithoutLinkLast2Days)}]"""
	makeComment(currentIssue, commentBody, user, visibility)
}

if (resultsOpenedProblems.total == 0 && resultsWithoutLinkLast2Days.total > 5) {
    final String commentBody = """Открытых связанных заявок, в которых может производиться исследование, по этому компоненту не найдено, но число инцидентов с этого сервера за последние 48 часов - [${resultsWithoutLinkLast2Days.total}|${jqlToUrl(queryWithoutLinkLast2Days)}] 
 Рассмотрите найденные заявки, возможно необходимо создать Problem"""
	makeComment(currentIssue, commentBody, user, visibility)
}

if (resultsRepeatable12h.total > 3 && resultsOpenedProblems.total == 0) {
    final String commentBody = """Открытых связанных заявок по этому компоненту не найдено, но число подобных алертов за последние 12 часов превысило 3. Текущее число: [${resultsRepeatable12h.total}|${jqlToUrl(queryRepeatable12h)}] 
 Возможно необходимо создать Problem и исследовать причину повторения алертов."""
	makeComment(currentIssue, commentBody, user, visibility)
}

if (resultsOpenIncidents.total > 2) {
	final String commentBody = """Обнаружены открытые алерты по этому компоненту. Текущее число: [${resultsOpenIncidents.total}|${jqlToUrl(queryOpenIncidents)}] 
 Возможно проблемы не ограничиваются этим алертом и необходимо исследовать ситуацию в комплексе"""
	makeComment(currentIssue, commentBody, user, visibility)
}

/*
The next thing 'result.getCustomFieldValue(ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName("Inc Good Time"))' is to get a date from custom field used in our company. It can be safely replaced with 'result.resolutiondate' or any other.
The whole 'if' construction afterwards is just to avoid 'null' in comment output.
replaceAll(":.{2}[.].{1}", "") is for beautify only, I don't need seconds and milliseconds. 
*/
if (listRepeatableDaily.size() >= 2) { //comment will trigger anyway, whether or not ticket is getting created.
	def commentRepeatableDaily = """Этот алерт возможно повторяется каждый день. За последнюю неделю найдены следующие заявки, приходящие примерно в одно время:
    """
    listRepeatableDaily.each {result ->; commentRepeatableDaily += """ ${result.key} - ${result.summary} Created: ${result.created.toString().replaceAll(":.{2}[.].{1,3}", "")} Resolved: ${if (result.getCustomFieldValue(ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName("Inc Good Time")) == null) {return "Not resolved"} else {result.getCustomFieldValue(ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName("Inc Good Time")).toString().replaceAll(":.{2}[.].{1}", "")}} 
    """}
	commentRepeatableDaily += """Проверьте вышенайденные заявки, и если необходимо создайте Problem для исследования."""
	makeComment(currentIssue, commentRepeatableDaily, user, visibility)
}

if (listRepeatableWeekly.size() >= 2) { //comment will trigger anyway, whether or not ticket is getting created.
	def commentRepeatableWeekly = """Этот алерт возможно повторяется каждую неделю. За последние 4 недели найдены следующие заявки, приходящие примерно в одно время:
    """
    listRepeatableWeekly.each {result ->; commentRepeatableWeekly += """ ${result.key} - ${result.summary} Created: ${result.created.toString().replaceAll(":.{2}[.].{1,3}", "")} Resolved: ${if (result.getCustomFieldValue(ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName("Inc Good Time")) == null) {return "Not resolved"} else {result.getCustomFieldValue(ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName("Inc Good Time")).toString().replaceAll(":.{2}[.].{1}", "")}} 
    """}
	commentRepeatableWeekly += """Проверьте вышенайденные заявки, и если необходимо создайте Problem для исследования."""
	makeComment(currentIssue, commentRepeatableWeekly, user, visibility)
}

/*
Part with actions, like creating tickets or linking
*/

//TODO: Same idea as for comments part. I need only one createLinkedProblem call. After that can add new functionality.

if (resultsOpenedLinkedHit.total == 1) {
    def linkType = ComponentAccessor.getComponent(IssueLinkTypeManager).issueLinkTypes.findByName("Problem/Incident")
    def destinationIssue = ComponentAccessor.issueManager.getIssueByCurrentKey(resultsOpenedLinkedHit.results.key.get(0))
    
    ComponentAccessor.issueLinkManager.createIssueLink(currentIssue.id, destinationIssue.id, linkType.id, 1L, user)
    final String commentBody = """Заявка прикреплена к ${destinationIssue}.
    Проверьте ${destinationIssue} и убедитесь что этот алерт с ним связан. Удалите связь, если прикрепление ошибочно."""
	makeComment(currentIssue, commentBody, user, visibility)
}

if (listRepeatableDaily.size() >= 3 && resultsOpenedLinkedHit.total == 0 && !ticketCreatedFlag) {
    String dailyProblemSummary = "[RPTISSUE] ${currentIssue.summary.replaceAll("Zabbix.* - |Prometheus |test|prod|preprod|dev", "")}" //this variable can be used to choose summary based on some condition, e.g based on projectName. Currently is just removes some words from issue summary based on my needs
	createLinkedProblem(currentIssue, listRepeatableDaily, "Problem", dailyProblemSummary, "Normal", "Найден ежедневно повторяющийся алерт", projectName, user, visibility)
    ticketCreatedFlag = true //Can be removed from the code in case creating multiple issues is required.
}

if (listRepeatableWeekly.size() >= 2 && resultsOpenedLinkedHit.total == 0 && !ticketCreatedFlag) {
    String weeklyProblemSummary = "[RPTISSUE] ${currentIssue.summary.replaceAll("Zabbix.* - |Prometheus |test|prod|preprod|dev", "")}" //this variable can be used to choose summary based on some condition, e.g based on projectName. Currently is just removes some words from issue summary based on my needs
	createLinkedProblem(currentIssue, listRepeatableWeekly, "Problem", weeklyProblemSummary, "Normal", "Найден еженедельно повторяющийся алерт", projectName, user, visibility)
    ticketCreatedFlag = true //Can be removed from the code in case creating multiple issues is required.
}

